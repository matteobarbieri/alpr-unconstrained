import os

import argparse

import json

import numpy as np

from utils import guess_last_frame


def parse_args():

    parser = argparse.ArgumentParser()

    parser.add_argument(
        'input_folder',
        help="The folder containing the original input images.")

    parser.add_argument(
        'aux_folder',
        help="The folder containing auxiliary files generated by the "
        "pipeline.")

    parser.add_argument(
        '--start_frame',
        type=int,
        default=1,
        help="The starting frame.")

    parser.add_argument(
        '--end_frame',
        type=int,
        # required=True,
        help="The ending frame.")

    parser.add_argument(
        '--window',
        type=int,
        default=5,
        help="The number of frame to use to improve plates detection")

    args = parser.parse_args()
    if args.end_frame is None:
        args.end_frame = guess_last_frame(args.input_folder)

    return args


def iterative_levenshtein(s, t):
    """
        iterative_levenshtein(s, t) -> ldist
        ldist is the Levenshtein distance between the strings
        s and t.
        For all i and j, dist[i,j] will contain the Levenshtein
        distance between the first i characters of s and the
        first j characters of t
    """
    rows = len(s)+1
    cols = len(t)+1
    dist = [[0 for x in range(cols)] for x in range(rows)]
    # source prefixes can be transformed into empty strings
    # by deletions:
    for i in range(1, rows):
        dist[i][0] = i
    # target prefixes can be created from an empty source string
    # by inserting the characters
    for i in range(1, cols):
        dist[0][i] = i

    for col in range(1, cols):
        for row in range(1, rows):
            if s[row-1] == t[col-1]:
                cost = 0
            else:
                cost = 1
            dist[row][col] = min(dist[row-1][col] + 1,      # deletion
                                 dist[row][col-1] + 1,      # insertion
                                 dist[row-1][col-1] + cost) # substitution
    # for r in range(rows):
        # print(dist[r])


    return dist[row][col]


def most_similar_plate(target_plate, plate_list, max_distance=2):
    """
    Given a target license plate and a list of candidate plates, find the one
    from the list which is at a distance of at most D from the target plate.

    Returns the index of the most similar plate

    Parameters
    ----------

    target_plate : str

    plate_list : list
        Each item is a dictionary
    """

    min_distance = np.inf
    mspi = None

    # TODO catch errors properly
    try:
        for i, p in enumerate(plate_list):
            ld = iterative_levenshtein(target_plate, p['plate_text'])

            if ld <= max_distance and ld < min_distance:
                min_distance = ld
                mspi = i
    except:
        pass

    return mspi


def recover_missing_plates(annotations_history, i, plates, window,  # noqa
                           min_occurrences):
    """
    Use the previous and following N frames to recover plates in current frame
    """

    # print("Found {} plates".format(len(plates)))
    plates_past = dict()
    plates_future = dict()

    # plate codes at current frame
    # current_plate_codes = [x['plate_text'] for x in plates]

    # past
    for i in range(i-window, i):
        for car in annotations_history[i]['cars']:
            for plate in car['plates']:

                if not plate['valid_plate']:
                    continue

                pt = plate['plate_text']

                if pt in plates_past:
                    plates_past[pt]['seen_at'].append(i)
                    plates_past[pt]['bb'][i] = plate['bounding_box']
                else:
                    plates_past[pt] = dict()
                    plates_past[pt]['seen_at'] = [i]
                    plates_past[pt]['bb'] = {}  # bounding boxes
                    plates_past[pt]['bb'][i] = plate['bounding_box']

    # future
    for i in range(i+1, i+1+window):
        for car in annotations_history[i]['cars']:
            for plate in car['plates']:

                if not plate['valid_plate']:
                    continue

                pt = plate['plate_text']

                if pt in plates_future:
                    plates_future[pt]['seen_at'].append(i)
                    plates_future[pt]['bb'][i] = plate['bounding_box']
                else:
                    plates_future[pt] = dict()
                    plates_future[pt]['seen_at'] = [i]
                    plates_future[pt]['bb'] = {}  # bounding boxes
                    plates_future[pt]['bb'][i] = plate['bounding_box']

    # Find plates with a valid code that appear before AND after the frame
    common_plate_codes = set(plates_future).intersection(set(plates_past))

    plates_recovered = 0
    plates_fixed = 0

    for plate_code in common_plate_codes:
        # In order to be added it must not be already present in current
        # license plates and have appeared a minimum number of times in
        # previous and future frames.

        mspi = most_similar_plate(plate_code, plates)
        # print(mspi)

        # If in the past there is a better version of the plate, replace the
        # code of the one in the current frame (XXX experimental)
        if mspi is not None:
            plates[mspi]['plate_text'] = plate_code
            plates_fixed += 1
            continue

        # if (
                # plate_code not in current_plate_codes and
                # len(plates_past[plate_code]['bb']) >= min_occurrences and
                # len(plates_future[plate_code]['bb']) >= min_occurrences):
        if (
                len(plates_past[plate_code]['bb']) >= min_occurrences and
                len(plates_future[plate_code]['bb']) >= min_occurrences):

            # Retrieve the last frame in which the plate was seen in previous
            # frames and the first in which it was seen in future ones.
            i_past = max(plates_past[plate_code]['seen_at'])
            i_future = min(plates_future[plate_code]['seen_at'])

            # Retrieve the bounding boxes for those instants
            bb_past = plates_past[plate_code]['bb'][i_past]
            bb_future = plates_future[plate_code]['bb'][i_future]

            # compute temporal displacement
            dt = i_future - i_past

            xc_past, yc_past = compute_center_coordinates(bb_past)
            xc_future, yc_future = compute_center_coordinates(bb_future)

            dx = (xc_future - xc_past)
            dy = (yc_future - yc_past)

            # Approximate bounding box at current frame
            bb_current = list(bb_past)  # Start from last seen bounding box
            bb_current[0] += (i_past - i)*(dx/dt)
            bb_current[1] += (i_past - i)*(dy/dt)

            # Create the entry for the reconstructed plate
            new_plate = {
                'bounding_box': bb_current,
                'valid_plate': True,
                'plate_text': plate_code,
            }

            plates.append(new_plate)

            plates_recovered += 1

    print("Recovered {} plates".format(plates_recovered))
    print("Fixed {} plates".format(plates_fixed))

    return plates


def compute_center_coordinates(bb):
    """
    Computes the coordinates of the center of a rectangular region

    bb = [x, y, w, h]
    """

    cx = bb[0] + bb[2]/2
    cy = bb[1] + bb[3]/2

    return cx, cy


def associate_plates_to_car(cars, plates):
    """
    Associate each plate to the closest available vehicle
    """

    # Keep track of indexes of cars that have already been assigned
    unavailable_cars_indexes = list()

    for p in plates:
        min_dist = np.inf

        px, py = compute_center_coordinates(p['bounding_box'])

        for ic, car in enumerate(cars):

            # Skip vehicles that have already been assigned a plate
            if ic in unavailable_cars_indexes:
                continue

            # Compute coordinates of the center of the vehicle's bb
            cx, cy = compute_center_coordinates(car['bounding_box'])

            dist = (cx - px)**2 + (cy - py)**2
            if dist < min_dist:
                min_dist = dist
                min_dist_car_index = ic

        # Assigne plate to the closest available car
        cars[min_dist_car_index]['plates'] = [p]

        # Mark car as unavailable
        unavailable_cars_indexes.append(min_dist_car_index)

    return cars


def remove_duplicate_plates(plates, annotations_history):

    excluded_plates_indexes = list()
    unique_plates_list = list()

    for i in range(len(plates)):

        # If it has been already excluded, skip
        if i in excluded_plates_indexes:
            continue

        p1 = plates[i]

        for j in range(i+1, len(plates)):

            p2 = plates[j]

            # Handle collision
            if area(p1['bounding_box'], p2['bounding_box']) is not None:

                # If they're the same skip the other one
                if p1['plate_text'] == p2['plate_text']:
                    excluded_plates_indexes.append(j)

                if p1['valid_plate'] and not p2['valid_plate']:
                    # If the first one is valid and the second one isn't,
                    # remove the second one.
                    excluded_plates_indexes.append(j)
                elif not p1['valid_plate'] and p2['valid_plate']:
                    # If the first one is NOT valid and the second one is
                    # valid, break the inner loop, thus preventing the first
                    # one to be added (it's the else part of the loop).
                    break
                else:
                    # Choose the one that appeared more frequently in the past
                    # TODO
                    excluded_plates_indexes.append(j)
        else:

            unique_plates_list.append(p1)

    return unique_plates_list


def process_annotations(annotations_history, i, window=25):
    """
    Process annotation for a given frame trying to correct wrong/missing data

    Parameters
    ----------

    annotations : dict
        Dictionary containing detections already pruned from duplicates
    """

    annotations_history

    cars = list()
    plates = list()

    for car in annotations_history[i]['cars']:

        # print(car)
        car_cp = dict(car)
        # del car_cp['plates']

        # Empty list of plates
        car_cp['plates'] = list()
        cars.append(car_cp)

        # Update the list of plates
        plates.extend(car['plates'])

    plates = recover_missing_plates(
        annotations_history, i, plates, window, 3)

    # print("Plates before pruning:")
    # print(plates)

    # Remove duplicate plates (i.e., those overlapping) by keeping those more
    # likely to be correct
    plates_unique = remove_duplicate_plates(plates, annotations_history)

    # print("Plates after pruning:")
    # print(plates_unique)

    # Finally asociate plate to car
    cars = associate_plates_to_car(cars, plates_unique)

    return {'cars': cars}


def area(a, b):  # returns None if rectangles don't intersect

    ax, ay, aw, ah = a
    bx, by, bw, bh = b

    # dx = min(a.xmax, b.xmax) - max(a.xmin, b.xmin)
    # dy = min(a.ymax, b.ymax) - max(a.ymin, b.ymin)

    dx = min(ax + aw, bx + bw) - max(ax, bx)
    dy = min(ay + ah, by + bh) - max(ay, by)

    if dx >= 0 and dy >= 0:
        return dx * dy


def main():

    args = parse_args()

    # Keep track of previous frames
    annotations_history = list()

    # First create a list of detections in all frames, in order to be able in a
    # second passage to fill in missing detections/correct them.
    for t in range(args.start_frame, args.end_frame+1):

        annotations_file = os.path.join(
            args.aux_folder,
            "frame{:05d}_annotations.json".format(t))

        # Load annotations from json file
        with open(annotations_file, 'r') as jf:
            annotations = json.load(jf)

        # N_before = sum([len(c['plates']) for c in annotations['cars']])

        # TODO
        # No longer remove duplicate plates, this is done in a following step
        # Remove duplicate coming from overlapping vehicles/large BB
        # annotations_unique = remove_duplicates(annotations)
        annotations_unique = annotations

        # N_after = sum([len(c['plates']) for c in annotations_unique['cars']])

        # print("License plates BEFORE pruning: {}".format(N_before))
        # print("License plates AFTER pruning: {}".format(N_after))

        # Save annotations for a given frame
        annotations_history.append(annotations_unique)

    # Then, try to fill in gaps using information from surrounding frames
    i = 0

    # Number of frames before and after to use to correct information
    # window = 25
    # args.window = 5

    for t in range(args.start_frame, args.end_frame+1):

        # Skip the first and last N frames (N = args.window)
        if i >= args.window and i < (args.end_frame - args.window):
            print("Processing frame {}".format(t))

            # Process annotations
            annotations_unique = process_annotations(
                annotations_history, i, args.window)

            annotations_unique_file = os.path.join(
                args.aux_folder,
                "frame{:05d}_annotations_unique.json".format(t))

            # Load annotations from json file
            with open(annotations_unique_file, 'w') as jf:
                annotations = json.dump(annotations_unique, jf, indent=4)
        else:
            print("Skipping frame {} (out of time window)".format(t))

        i += 1


if __name__ == "__main__":
    main()
