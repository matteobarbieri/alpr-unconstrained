import os

import argparse

import json

from utils import guess_last_frame

def parse_args():

    parser = argparse.ArgumentParser()

    parser.add_argument(
        'input_folder',
        help="The folder containing the original input images.")

    parser.add_argument(
        'aux_folder',
        help="The folder containing auxiliary files generated by the "
        "pipeline.")

    parser.add_argument(
        '--start_frame',
        type=int,
        default=1,
        help="The starting frame.")

    parser.add_argument(
        '--end_frame',
        type=int,
        # required=True,
        help="The ending frame.")

    parser.add_argument(
        '--width',
        type=int,
        help="The width of the original image")

    parser.add_argument(
        '--height',
        type=int,
        help="The height of the original image")

    args = parser.parse_args()
    if args.end_frame is None:
        args.end_frame = guess_last_frame(args.input_folder)

    return args


def recover_missing_plates(annotations_history, i, plates, window,
                           min_occurrences):
    """
    Use the previous and following N frames to recover plates in current frame
    """

    # print("Found {} plates".format(len(plates)))
    plates_past = dict()
    plates_future = dict()

    # plate codes at current frame
    current_plate_codes = [x['plate_text'] for x in plates]

    # past
    for i in range(i-window, i):
        for car in annotations_history[i]['cars']:
            for plate in car['plates']:

                if not plate['valid_plate']:
                    continue

                pt = plate['plate_text']

                if pt in plates_past:
                    plates_past[pt]['seen_at'].append(i)
                    plates_past[pt]['bb'][i] = plate['bounding_box']
                else:
                    plates_past[pt] = dict()
                    plates_past[pt]['seen_at'] = [i]
                    plates_past[pt]['bb'] = {}  # bounding boxes
                    plates_past[pt]['bb'][i] = plate['bounding_box']

    # future
    for i in range(i+1, i+1+window):
        for car in annotations_history[i]['cars']:
            for plate in car['plates']:

                if not plate['valid_plate']:
                    continue

                pt = plate['plate_text']

                if pt in plates_future:
                    plates_future[pt]['seen_at'].append(i)
                    plates_future[pt]['bb'][i] = plate['bounding_box']
                else:
                    plates_future[pt] = dict()
                    plates_future[pt]['seen_at'] = [i]
                    plates_future[pt]['bb'] = {}  # bounding boxes
                    plates_future[pt]['bb'][i] = plate['bounding_box']

    # Find plates with a valid code that appear before AND after the frame
    common_plate_codes = set(plates_future).intersection(set(plates_past))

    # print(sorted(common_plate_codes))
    # print(sorted(current_plate_codes))

    plates_recovered = 0

    for plate_code in common_plate_codes:
        # In order to be added it must not be already present in current
        # license plates and have appeared a minimum number of times in
        # previous and future frames.
        if (
                plate_code not in current_plate_codes and
                len(plates_past[plate_code]['bb']) >= min_occurrences and
                len(plates_future[plate_code]['bb']) >= min_occurrences):

            # Retrieve the last frame in which the plate was seen in previous
            # frames and the first in which it was seen in future ones.
            i_past = max(plates_past[plate_code]['seen_at'])
            i_future = min(plates_future[plate_code]['seen_at'])

            # Retrieve the bounding boxes for those instants
            bb_past = plates_past[plate_code]['bb'][i_past]
            bb_future = plates_future[plate_code]['bb'][i_future]

            # compute temporal displacement
            dt = i_future - i_past
            dx = (bb_future[0] + bb_future[2]/2 - bb_past[0] - bb_past[2]/2)
            dy = (bb_future[1] + bb_future[3]/3 - bb_past[1] - bb_past[3]/3)

            # Approximate bounding box at current frame
            bb_current = list(bb_past)  # Start from last seen bounding box
            bb_current[0] += (i_past - i)*(dx/dt)
            bb_current[1] += (i_past - i)*(dy/dt)

            # Create the entry for the reconstructed plate
            new_plate = {
                'bounding_box': bb_current,
                'valid_plate': True,
                'plate_text': plate_code,
            }

            plates.append(new_plate)

            plates_recovered += 1

    print("Recovered {} plates".format(plates_recovered))


def associate_plates_to_car(cars, plates):

    pass


def process_annotations(annotations_history, i, window=25):
    """
    Process annotation for a given frame trying to correct wrong/missing data

    Parameters
    ----------

    annotations : dict
        Dictionary containing detections already pruned from duplicates
    """

    annotations_history

    cars = list()
    plates = list()

    for car in annotations_history[i]['cars']:

        # print(car)
        car_cp = dict(car)
        # del car_cp['plates']

        # Empty list of plates
        car_cp['plates'] = list()
        cars.append(car_cp)

        # Update the list of plates
        plates.extend(car['plates'])

        # for plate in car['plates']:
            # print(plate)

    plates = recover_missing_plates(
        annotations_history, i, plates, window, 3)

    associate_plates_to_car(cars, plates)

    # print(cars)
    # print(len(cars))

    # 1/0

    return


def area(a, b):  # returns None if rectangles don't intersect

    ax, ay, aw, ah = a
    bx, by, bw, bh = b

    # dx = min(a.xmax, b.xmax) - max(a.xmin, b.xmin)
    # dy = min(a.ymax, b.ymax) - max(a.ymin, b.ymin)

    dx = min(ax + aw, bx + bw) - max(ax, bx)
    dy = min(ay + ah, by + bh) - max(ay, by)

    if dx >= 0 and dy >= 0:
        return dx * dy


def duplicate_license_exists(p, uid, plates, ignore_car_ids):
    """
    Check if there is another license plate from a different vehicle with the
    same extracted text.
    """

    for v_id, op in plates:

        # Skip already removed cars
        if v_id in ignore_car_ids:
            continue

        # if op['plate_text'] == p['plate_text'] and uid != v_id:
        if area(p['bounding_box'], op['bounding_box']) is not None \
                and uid != v_id:
            return True

    return False


def remove_duplicate_license(car, plates, ignore_car_ids):
    new_plates_list = list()

    for p in car['plates']:

        if not duplicate_license_exists(p, car['uid'], plates, ignore_car_ids):
        # if (car['uid'], p['plate_text']) not in [  # noqa
                # (uid, op['plate_text']) for (uid, op) in plates]:

            new_plates_list.append(p)
        else:
            ignore_car_ids.append(car['uid'])

    car['plates'] = new_plates_list


def remove_duplicates(annotations):

    plates = list()

    uid = 1

    for c in annotations['cars']:
        c['uid'] = uid
        plates.extend([(uid, p) for p in c['plates']])
        uid += 1

    # List of cleaned up cars
    cars = list()

    ignore_car_ids = list()

    for c in annotations['cars']:

        # Make a copy of the annotation for a single car
        c_copy = dict(c)


        # if len(c_copy['plates']) <= 1:
            # cars.append(c_copy)
        # else:
            # remove_duplicate_license(c_copy, plates)
            # cars.append(c_copy)

        remove_duplicate_license(c_copy, plates, ignore_car_ids)

        cars.append(c_copy)

    annotations_unique = dict()
    annotations_unique['cars'] = cars

    return annotations_unique


def main():

    args = parse_args()

    # Keep track of previous frames
    annotations_history = list()

    # First create a list of detections in all frames, in order to be able in a
    # second passage to fill in missing detections/correct them.
    for t in range(args.start_frame, args.end_frame+1):

        annotations_file = os.path.join(
            args.aux_folder,
            "frame{:05d}_annotations.json".format(t))

        # Load annotations from json file
        with open(annotations_file, 'r') as jf:
            annotations = json.load(jf)

        N_before = sum([len(c['plates']) for c in annotations['cars']])

        # Remove duplicate coming from overlapping vehicles/large BB
        annotations_unique = remove_duplicates(annotations)

        N_after = sum([len(c['plates']) for c in annotations_unique['cars']])

        # print("License plates BEFORE pruning: {}".format(N_before))
        # print("License plates AFTER pruning: {}".format(N_after))

        # Save annotations for a given frame
        annotations_history.append(annotations_unique)


    # Then, try to fill in gaps using information from surrounding frames
    i = 0

    # Number of frames before and after to use to correct information
    window = 25

    for t in range(args.start_frame, args.end_frame+1):

        # Skip the first and last N frames (N = window)
        if i >= window and i < (args.end_frame - window):

            # Process annotations
            process_annotations(annotations_history, i, window)

            continue

            annotations_unique_file = os.path.join(
                args.aux_folder,
                "frame{:05d}_annotations_unique.json".format(t))

            # Load annotations from json file
            with open(annotations_unique_file, 'w') as jf:
                annotations = json.dump(annotations_unique, jf, indent=4)

        i += 1


if __name__ == "__main__":
    main()
