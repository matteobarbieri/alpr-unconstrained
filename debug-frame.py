import os

import argparse

import json

from post_processing import process_annotations


def parse_args():

    parser = argparse.ArgumentParser()

    parser.add_argument(
        'aux_folder',
        help="The folder containing auxiliary files generated by the "
        "pipeline.")

    parser.add_argument(
        'target_frame',
        type=int,
        help="The target frame to debug.")

    parser.add_argument(
        '--window',
        type=int,
        default=25,
        help="Number of frames before and after to use to correct detections.")

    args = parser.parse_args()

    # Manually set start and end frame
    args.start_frame = args.target_frame - args.window
    args.end_frame = args.target_frame + args.window

    return args


def main():

    args = parse_args()

    # Keep track of previous frames
    annotations_history = list()

    # First create a list of detections in all frames, in order to be able in a
    # second passage to fill in missing detections/correct them.
    for t in range(args.start_frame, args.end_frame+1):

        annotations_file = os.path.join(
            args.aux_folder,
            "frame{:05d}_annotations.json".format(t))

        # Load annotations from json file
        with open(annotations_file, 'r') as jf:
            annotations = json.load(jf)

        # Save annotations for a given frame
        annotations_history.append(annotations)

    # Then, try to fill in gaps using information from surrounding frames
    i = args.window

    print("Processing frame {}".format(args.target_frame))

    # Process annotations
    annotations_unique = process_annotations(
        annotations_history, i, args.window)

    annotations_unique_file = os.path.join(
        args.aux_folder,
        "frame{:05d}_annotations_unique.json".format(args.target_frame))

    # Load annotations from json file
    with open(annotations_unique_file, 'w') as jf:
        annotations = json.dump(annotations_unique, jf, indent=4)


if __name__ == "__main__":
    main()
