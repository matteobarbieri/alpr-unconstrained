import argparse

import os

from PIL import Image, ImageDraw, ImageFont

# from glob import glob

# from src.utils import crop_region, image_files_from_folder
from src.utils import image_files_from_folder

import pandas as pd

import time

# TEXT_BG_COLOR = (203, 227, 21)  # acid green
# TEXT_BG_COLOR = (0, 255, 0)  # green
TEXT_BG_COLOR = (252, 15, 192)  # pink
TEXT_FG_COLOR = (0, 0, 0)  # black

# Icons
SYMBOL_CAR = " "
SYMBOL_BUS = ""
SYMBOL_TRUCK = ""

VEHICLE_SYMBOLS = {
    'car': SYMBOL_CAR,
    'bus': SYMBOL_BUS,
    'truck': SYMBOL_TRUCK,
}

# TODO move somewhere else
import re
# LP_PATTERN = re.compile("[A-F]{2}[\d]{3}[A-Z]{2}")
LP_PATTERN = re.compile("[A-Z]{2}[\d]{3}[A-Z]{2}")


def parse_args():

    parser = argparse.ArgumentParser()

    parser.add_argument(
        'input_folder',
        help="The folder containing the original input images.")

    parser.add_argument(
        'aux_folder',
        help="The folder containing auxiliary files generated by the "
        "pipeline.")

    return parser.parse_args()


def validate_lp_text(lp_text):
    """
    Optional step to validate license plate
    E.g.: italian ones should be two letters, three digits and two letters
    """

    return LP_PATTERN.match(lp_text) is not None


def format_lp(lp_text):
    """
    Add spaces in lp text to improve readability

    From:

        AB123FW

    To:

        AB 123 FW

    """

    return lp_text
    # return lp_text[:2] + " " + lp_text[2:5] + " " + lp_text[5:]

def draw_corners(x, y, w, h, segment_length,
                 pil_draw, color=(0, 255, 0), width=3):

    # Draw two lines for each corner

    # NW
    pil_draw.line([x, y, x+segment_length, y], fill=color, width=3)
    pil_draw.line([x, y, x, y+segment_length], fill=color, width=3)

    # NE
    pil_draw.line([x+w-segment_length, y, x+w, y], fill=color, width=3)
    pil_draw.line([x+w, y, x+w, y+segment_length], fill=color, width=3)

    # SE
    pil_draw.line([x+w-segment_length, y+h, x+w, y+h], fill=color, width=3)
    pil_draw.line([x+w, y+h-segment_length, x+w, y+h], fill=color, width=3)

    # SW
    pil_draw.line([x, y+h, x+segment_length, y+h], fill=color, width=3)
    pil_draw.line([x, y+h-segment_length, x, y+h], fill=color, width=3)


def outline_bounding_box(x, y, w, h, pil_draw, color):
    """
    Draw an outline for a bounding box
    """

    # Determine which is the shorter side
    min_len = min(h, h)

    # Determine segment length
    segment_length = min(min_len/3, 50)

    # Draw corners
    draw_corners(x, y, w, h, segment_length, pil_draw, color=color, width=3)


def annotate_license_plate2(x, y, w, h, lp_text, pil_draw,
                            font, font_large,
                            padding, segment_length_ratio, line_length_ratio,
                            vehicle_category, bg_color, fg_color):
    """
    line_length_ration : float
        Between 0 and 1, the length of the central top line
    """

    # Adjust geometry to take padding into account
    x_p = x - padding
    y_p = y - padding
    w_p = w + 2 * padding
    h_p = h + 2 * padding

    # Compute length of corner segment in pixel
    segment_length = w_p * segment_length_ratio

    # Draw corners
    draw_corners(x_p, y_p, w_p, h_p, segment_length,
                 pil_draw, color=bg_color, width=3)

    # Compute the length of the horizontal line
    line_length = w_p * line_length_ratio
    line_height = 1.5 * line_length

    # Compute x coordinate of the lp center
    x_c = x_p + w_p/2

    # Draw the horizontal line
    pil_draw.line([x_c - line_length/2, y_p, x_c + line_length/2, y_p],
                  fill=bg_color, width=3)

    # Draw the vertical line
    pil_draw.line([x_c, y_p-line_height, x_c, y_p],
                  fill=bg_color, width=3)

    # Compute coordinates for the label
    x_symbol = x_c + 8
    y_symbol = y_p - line_height

    # Beautify license plate text
    lp_text_formatted = format_lp(lp_text)

    # Draw the square for the symbol
    TEXT_BOX_WIDTH = (len(lp_text_formatted)) * 19
    TEXT_BOX_HEIGHT = 30

    # Draw the rectangle for the symbol
    pil_draw.rectangle(
        [x_symbol, y_symbol, x_symbol+TEXT_BOX_HEIGHT,
         y_symbol + TEXT_BOX_HEIGHT],
        fill=bg_color)

    # Compute coordinates for the acutal LP text
    x_text = x_symbol + TEXT_BOX_HEIGHT + 5
    y_text = y_symbol

    # Draw the rectangle for the text
    pil_draw.rectangle(
        [x_text, y_text, x_text+TEXT_BOX_WIDTH, y_text + TEXT_BOX_HEIGHT],
        fill=bg_color)

    # Draw the symbol corresponding to the identified vehicle
    pil_draw.text(
        (x_symbol + 3, y_symbol - 8),
        VEHICLE_SYMBOLS[vehicle_category],
        fg_color, font=font_large)

    # Finally, write the actual LP text in the square
    pil_draw.text(
        (x_text + 5, y_text - 2),
        lp_text_formatted, fg_color, font=font)


def annotate_license_plate(x, y, w, h, lp_text, pil_draw,
                           font, font_large,
                           vehicle_category, bg_color, fg_color):
    """
    Draw an outline for a bounding box

    bg_color : tuple
        Color of background box, lines etc.

    fg_color : tuple
        Color of the text
    """


    # Draw the outline of the license plate
    pil_draw.rectangle(
        [
            x,
            y,
            x + w,
            y + h],
        outline=bg_color, width=3)

    # Beautify license plate text
    lp_text_formatted = format_lp(lp_text)

    # Draw a full rectangle for the LP background
    # TODO replace fixed offset values with parameters
    # TEXT_BOX_WIDTH = (len(lp_text_formatted) + 2) * 20 + 5
    TEXT_BOX_WIDTH = (len(lp_text_formatted) + 2) * 19
    TEXT_BOX_HEIGHT = 30
    pil_draw.rectangle(
        [
            x,
            y - TEXT_BOX_HEIGHT,
            x + TEXT_BOX_WIDTH,
            y],
        fill=bg_color)

    # Draw the symbol corresponding to the identified vehicle
    # TODO draw the correct symbol
    pil_draw.text(
        (x + 5, y - TEXT_BOX_HEIGHT - 8),
        VEHICLE_SYMBOLS[vehicle_category],
        fg_color, font=font_large)

    # Finally, write the actual LP text in the square
    pil_draw.text(
        (x + 5 + 35, y - TEXT_BOX_HEIGHT - 2),
        lp_text_formatted, fg_color, font=font)


def process_car_crop(car_id, car_row, base_image_name,
                     img_full, pil_draw, font, font_large, args):

    # Extract size from img_full
    w, h = img_full.size

    # Reconstruct crop coordinates and size
    car_crop_w = car_row.w * w
    car_crop_h = car_row.h * h

    car_crop_x = car_row.x * w - car_crop_w/2
    car_crop_y = car_row.y * h - car_crop_h/2

    # Extract category of the vehicle
    vehicle_category = car_row.category

    # Look for all detected licence plates for that car (most of the time
    # it's just one)
    try:
        car_lp_detections_file = os.path.join(
            args.aux_folder,
            "{}_car_{}_lp.txt".format(base_image_name[:-4], car_id))

        lp_df = pd.read_csv(
            car_lp_detections_file,
            header=None, sep=' ',
            names=['cc', 'x', 'y', 'w', 'h'])

        for lp_id, lp_row in lp_df.iterrows():

            # Compute coordinates of lp crop (these are with respect to the car
            # crop)
            lp_crop_w = lp_row.w * car_crop_w
            lp_crop_h = lp_row.h * car_crop_h

            # lp_crop_x = lp_row.x * car_crop_w
            # lp_crop_y = lp_row.y * car_crop_h
            lp_crop_x = lp_row.x * car_crop_w - lp_crop_w/2
            lp_crop_y = lp_row.y * car_crop_h - lp_crop_h/2

            try:

                car_lp_ocrout_file = os.path.join(
                    args.aux_folder,
                    "{}_car_{}_{}_lp_str.txt".format(
                        base_image_name[:-4], car_id, lp_id))

                with open(car_lp_ocrout_file, 'r') as lp_ocr_f:
                    lp_text = lp_ocr_f.read().strip()

                if validate_lp_text(lp_text):

                    # Draw a box on original image
                    # Compute absolute coordinates of the lp crop
                    lp_crop_x_absolute = lp_crop_x + car_crop_x
                    lp_crop_y_absolute = lp_crop_y + car_crop_y

                    # print("Drawing rectangle at {}, {} ({})".format(
                        # lp_crop_x_absolute, lp_crop_y_absolute, lp_text))

                    # Draw a cool outline of the vehicle
                    outline_bounding_box(
                        car_crop_x, car_crop_y, car_crop_w,car_crop_h,
                        pil_draw, (0, 255, 0))

                    # Draw license plate annotation
                    # annotate_license_plate(
                        # lp_crop_x_absolute, lp_crop_y_absolute,
                        # lp_crop_w, lp_crop_h, lp_text, pil_draw,
                        # font, font_large,
                        # vehicle_category,
                        # TEXT_BG_COLOR, TEXT_FG_COLOR)

                    annotate_license_plate2(
                        lp_crop_x_absolute, lp_crop_y_absolute,
                        lp_crop_w, lp_crop_h, lp_text, pil_draw,
                        font, font_large,
                        10, 0.15, 0.4,
                        vehicle_category,
                        TEXT_BG_COLOR, TEXT_FG_COLOR)


            except Exception as e:
                # print(e)
                pass

    except Exception as e:
        print(e)
        pass


def process_image(img_path, font, font_large, args):
    """
    Take as input the path of one input image and the arguments passed to the
    script and proceeds to retrieving all required information to display the
    license plate number close to the car.
    """

    # Extract filename
    base_image_name = os.path.basename(img_path)

    # TODO DEBUG remove
    # print(base_image_name)

    # Load the entire image
    img_full = Image.open(img_path)

    pil_draw = ImageDraw.Draw(img_full)

    tic = time.time()

    # First get the list of cars
    cars_df = pd.read_csv(
        os.path.join(
            args.aux_folder, "{}_cars.txt".format(base_image_name[:-4])),
        header=None, sep=' ',
        names=['cc', 'x', 'y', 'w', 'h', 'category'])

    # for car_id, car_row in enumerate(cars_df.iterrows()):
    for car_id, car_row in cars_df.iterrows():

        process_car_crop(
            car_id, car_row, base_image_name, img_full, pil_draw,
            font, font_large, args)

    toc = time.time()

    print("Done, elapsed time = {}".format(toc-tic))
    print("Done, writing image")

    # Save the image with bb
    img_full.save(
        os.path.join(args.aux_folder, base_image_name[:-4]+"_output.png"),
        "PNG")

    return


def main():

    args = parse_args()

    font_filename = \
        "DejaVu Sans Mono Nerd Font Complete Mono.ttf"

    # Load the font used to write license plates text above actual recognized
    # plates.
    font = ImageFont.truetype(
        os.path.join('data', 'fonts', font_filename), size=30)

    # Load a second copy of the font for symbols
    font_large = ImageFont.truetype(
        os.path.join('data', 'fonts', font_filename), size=40)


    # Retrieve the names of the input images
    imgs_paths = image_files_from_folder(args.input_folder)

    for img_path in imgs_paths:
        process_image(img_path, font, font_large, args)


if __name__ == "__main__":
    main()
