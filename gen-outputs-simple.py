import argparse

import os

from PIL import Image, ImageDraw, ImageFont

# from glob import glob

# from src.utils import crop_region, image_files_from_folder
from src.utils import image_files_from_folder

import pandas as pd

import time

TEXT_BG_COLOR = (203, 227, 21)
TEXT_BG_COLOR = (0, 255, 0)

def parse_args():

    parser = argparse.ArgumentParser()

    parser.add_argument(
        'input_folder',
        help="The folder containing the original input images.")

    parser.add_argument(
        'aux_folder',
        help="The folder containing auxiliary files generated by the "
        "pipeline.")

    return parser.parse_args()


def validate_lp_text(lp_text):
    """
    Optional step to validate license plate
    E.g.: italian ones should be two letters, three digits and two letters
    """
    # TODO replace with something better
    return True


def process_car_crop(car_id, car_row, base_image_name,
                     img_full, pil_draw, font, args):

    # Extract size from img_full
    w, h = img_full.size

    # Reconstruct crop coordinates and size
    car_crop_w = car_row.w * w
    car_crop_h = car_row.h * h

    # car_crop_x = car_row.x * w
    # car_crop_y = car_row.y * h
    car_crop_x = car_row.x * w - car_crop_w/2
    car_crop_y = car_row.y * h - car_crop_h/2

    # Look for all detected licence plates for that car (most of the time
    # it's just one)
    try:
        car_lp_detections_file = os.path.join(
            args.aux_folder,
            "{}_car_{}_lp.txt".format(base_image_name[:-4], car_id))

        lp_df = pd.read_csv(
            car_lp_detections_file,
            header=None, sep=' ',
            names=['cc', 'x', 'y', 'w', 'h'])

        for lp_id, lp_row in lp_df.iterrows():

            # Compute coordinates of lp crop (these are with respect to the car
            # crop)
            lp_crop_w = lp_row.w * car_crop_w
            lp_crop_h = lp_row.h * car_crop_h

            # lp_crop_x = lp_row.x * car_crop_w
            # lp_crop_y = lp_row.y * car_crop_h
            lp_crop_x = lp_row.x * car_crop_w - lp_crop_w/2
            lp_crop_y = lp_row.y * car_crop_h - lp_crop_h/2

            try:

                car_lp_ocrout_file = os.path.join(
                    args.aux_folder,
                    "{}_car_{}_{}_lp_str.txt".format(
                        base_image_name[:-4], car_id, lp_id))

                with open(car_lp_ocrout_file, 'r') as lp_ocr_f:
                    lp_text = lp_ocr_f.read().strip()

                if validate_lp_text(lp_text):

                    # Draw a box on original image
                    # Compute absolute coordinates of the lp crop
                    lp_crop_x_absolute = lp_crop_x + car_crop_x
                    lp_crop_y_absolute = lp_crop_y + car_crop_y

                    # print("Drawing rectangle at {}, {} ({})".format(
                        # lp_crop_x_absolute, lp_crop_y_absolute, lp_text))

                    # Draw the outline of the license plate
                    pil_draw.rectangle(
                        [
                            lp_crop_x_absolute,
                            lp_crop_y_absolute,
                            lp_crop_x_absolute + lp_crop_w,
                            lp_crop_y_absolute + lp_crop_h],
                        outline=TEXT_BG_COLOR, width=3)

                    # Draw a full rectangle for the LP background
                    # TODO replace fixed offset values with parameters
                    TEXT_BOX_WIDTH = len(lp_text) * 20 + 5
                    TEXT_BOX_HEIGHT = 30
                    pil_draw.rectangle(
                        [
                            lp_crop_x_absolute,
                            lp_crop_y_absolute - TEXT_BOX_HEIGHT,
                            lp_crop_x_absolute + TEXT_BOX_WIDTH,
                            lp_crop_y_absolute],
                        fill=TEXT_BG_COLOR)

                    # Finally, write the actual LP text in the square
                    pil_draw.text(
                        (lp_crop_x_absolute + 2,
                            lp_crop_y_absolute - TEXT_BOX_HEIGHT - 5),
                        lp_text, (0, 0, 0), font=font)

                    # A rect around the car (for DEBUG)
                    # pil_draw.rectangle(
                        # [
                            # car_crop_x,
                            # car_crop_y,
                            # car_crop_x + car_crop_w,
                            # car_crop_y + car_crop_h],
                        # outline=(0, 255, 0), width=2)

                # DEBUG remove
                # print("Text for {} car {}: {}".format(
                    # base_image_name[:-4], car_id, lp_text))

            except Exception as e:
                print(e)
                pass

    except Exception as e:
        print(e)
        pass


def process_image(img_path, font, args):
    """
    Take as input the path of one input image and the arguments passed to the
    script and proceeds to retrieving all required information to display the
    license plate number close to the car.
    """

    # Extract filename
    base_image_name = os.path.basename(img_path)

    # TODO DEBUG remove
    # print(base_image_name)

    # Load the entire image
    img_full = Image.open(img_path)

    pil_draw = ImageDraw.Draw(img_full)

    tic = time.time()

    # First get the list of cars
    cars_df = pd.read_csv(
        os.path.join(
            args.aux_folder, "{}_cars.txt".format(base_image_name[:-4])),
        header=None, sep=' ',
        names=['cc', 'x', 'y', 'w', 'h'])

    # for car_id, car_row in enumerate(cars_df.iterrows()):
    for car_id, car_row in cars_df.iterrows():

        process_car_crop(
            car_id, car_row, base_image_name, img_full, pil_draw, font, args)

    toc = time.time()

    print("Done, elapsed time = {}".format(toc-tic))
    print("Done, writing image")

    # Save the image with bb
    img_full.save(
        os.path.join(args.aux_folder, base_image_name[:-4]+"_output.png"),
        "PNG")

    return


def main():

    args = parse_args()

    font = ImageFont.truetype(
        os.path.join('data', 'fonts', "OpenSans-Regular.ttf"), size=30)

    # Retrieve the names of the input images
    imgs_paths = image_files_from_folder(args.input_folder)

    for img_path in imgs_paths:
        process_image(img_path, font, args)

        # TODO debug, remove
        break

    # print(imgs_paths)


if __name__ == "__main__":
    main()
